% ! TeX root = ./document.tex
\documentclass[8pt, aspectratio=169, handout]{beamer}
\input{partials/package.tex}
\input{partials/theme-configuration.tex}
\input{partials/title-content.tex}
\bibliography{biblio.bib}
\begin{document}
\begin{frame}[plain]
  \begin{backgroundblock} 
    \includegraphics[width=\paperwidth]{img/network.jpg} 
  \end{backgroundblock} 
\titlepage
\end{frame}
\addtocounter{framenumber}{-1}
\section{Background}
\begin{frame}{Context}
  \begin{card}[Engeneering distributed Collectives Intelligence]
    \begin{itemize}
      \item \highlight{Why?} \faArrowRight \, distributed artificial system/socio-technical/cyber-physical deal with ``collectives''
      \begin{multicols}{2}
      \begin{itemize}
        \item Swarm robotics
        \item Crowd Engeneering
        \item Smart cities/building/house
      \end{itemize}
      \begin{itemize}
        \item Wireless Sensor Networks
        \item Industry 4.0
        \item Traffic management
      \end{itemize}
      \end{multicols}
      \item Environement interactions \faPlus \, Large network of cyber physical/artificial entities
    \end{itemize}
  \end{card}
  \begin{alarm}[ \faExclamationTriangle \, \textbf{How}?]
    \highlight{Engeneering perspective} \faArrowRight \, Models, tools, simulations, abstractions, programming languages, \dots
  \end{alarm}
\end{frame}

\begin{frame}{A programming approach: Aggregate Computing~\cite{beal2015aggregate-programming}}
    \begin{columns}
      \begin{column}[c]{0.8\textwidth}
        \begin{card}[What?]
          \begin{itemize}
            \item[\success{\faInfo}] a \emph{macro-programming} paradigm for Collective Adaptive Systems (CASs)
            \begin{itemize}
              \item \highlight{macro-programming} \faArrowRight \, devising the macroscopic behaviour of systems of computational entities
              \item \highlight{Motto}: \emph{program the aggregate, not the individual devices}
              \item \item A way to \emph{program} Collective Intelligence \& Self-organisation 
            \end{itemize}
            \item[\success{\faInfo}] Collective Behaviour expressed through \emph{Computational fields} (short---\emph{fields})
            \begin{itemize}
              \item Distributed spacetime data structure \faArrowRight \, $F: (Devices, Time) \rightarrow (Values)$
            \end{itemize}
            \item[\success{\faInfo}] \highlight{Fields calcus} \faArrowRight \, core language to express fields manipulation
            \begin{itemize}
              \item Aggregate computing \faArrowRight \, Field calcus = \, Functional Programming \faArrowRight \, Lambda calculus
              \item function application (computation + branching)
              \item stateful evolution (\highlight{rep})
              \item local interaction (\highlight{nbr})
            \end{itemize}
          \end{itemize}
        \end{card}
      \end{column}
      \begin{column}[c]{0.2\textwidth}
        \cardImg{img/ac-vertical.png}{\textwidth}
      \end{column}
    \end{columns}
\end{frame}
\begin{frame}[allowframebreaks, fragile]{What can we express with Aggregate Computing?}
  \centering
  \cardImg{img/channel.png}{0.6\textwidth}
  \begin{card}[Aggregate Program specification]
    \begin{minted}{scala}
def channel(source: Boolean, target: Boolean, width: Double): Boolean = {
  distanceTo(source) + distanceTo(target) <= distanceBetween(source, target) + width
}
    \end{minted}
  \end{card}
  \cardImg{img/composition.png}{0.45\textwidth}
\end{frame}
\begin{frame}{Aggregate Computing: how?}
  \begin{card}[Requirements]
    \begin{itemize}
      \item \highlight{Structure}: network, based on some neighbouring relationship
      \item \highlight{Dynamics}: repeated, async execution of an ``aggregate'' protocol    
    \end{itemize}
  \end{card}
  \begin{card}[Execution Model]
    \begin{itemize}
      \item[\success{\faInfo}] \highlight{Asynchronous execution rounds}:
      \begin{itemize}
        \item [\highlight{1-}] \textbf{perceive} local context (messages from neighbours, sensed environment state) 
        \item [\highlight{2-}] \textbf{compute} \emph{aggregate program} against local context
        \item [\highlight{3-}] \textbf{act} on local context (send messages to neighbours, act on environment)
      \end{itemize}
    \end{itemize}
  \end{card}
\end{frame}
\begin{frame}{Aggregate Computing: Layered Approach}
  \centering
  \cardImg{img/aggregate-computing-stack.png}{0.5\textwidth}
\end{frame}
\section{Research Roadmap}
\begin{frame}{Aggregate Computing Framework: Goals and Means}
  \begin{columns}
    \begin{column}[t]{0.6\textwidth}
      \begin{card}[Goals]
        \begin{itemize}
          \item[\success{\faInfo}] \highlight{Functionality} \faArrowRight \, achieving some collective behaviour
          \begin{itemize}
            \item environment monitoring \& control
            \item drone rescues
            \item crowd detection
          \end{itemize}
          \item[\success{\faInfo}] \highlight{Non-Functionality} \faArrowRight \, cost related to the functionality.
          \begin{itemize}
            \item \emph{time efficiency} \faArrowRight \, convergence time of collective specifications
            \item \emph{communication efficiency} \faArrowRight \, amount of data exchanged
            \item \emph{execution efficiency} \faArrowRight \, rounds performed to achieve a collective behaviour
            \item \emph{energy efficiency} \faArrowRight \, communication \faPlus \, execution efficiency
            \item \emph{dependability}
          \end{itemize}
        \end{itemize}
      \end{card}
    \end{column}

    \begin{column}[t]{0.4\textwidth}
      \begin{card}[Means]
        \begin{itemize}  
          \item[\success{\faInfo}] \highlight{Algorithms}
          \item[\success{\faInfo}] \highlight{Execution strategy}
          \item[\success{\faInfo}] \highlight{System structure}
        \end{itemize}
      \end{card}
    \end{column}
  \end{columns}
\end{frame}

\begin{frame}{Aggregate Computing \faPlus \,  Machine Learning}
  \begin{card}[\textbf{Vision}]
    \begin{itemize}
      \item State-of-the-art \faArrowRight \, means devised through \emph{hand-crafted} solution (heuristics, models, \dots)
      \item Machine Learning \faArrowRight \, \emph{augument} (or replace) traditional solution 
      \item[\success{\faThumbsUp}] \highlight{Potential benefit / Opportunities}
      \begin{itemize}
        \item Automatic desing of CI
        \item Coherent and high-level specification (through AC programming stack) \faPlus \, learn by doing or from data \faArrowRight \, hybrid programming approach
        \item Improving adaptivity of collective specifications
      \end{itemize}
      \item[\failure{\faThumbsDown}] Challenges
      \begin{itemize}
        \item Distribution \& decentralisation 
        \item Partial observability
        \item Many agent coordinations
        \item Eventual nature of collective computation
      \end{itemize}
    \end{itemize}
  \end{card}
\end{frame}
\begin{frame}{Aggregate Computing \faPlus \,  Machine Learning: Roadmap}
  \centering
  \cardImg{img/roadmap}{0.8\textwidth}
\end{frame}
\begin{frame}[allowframebreaks]{Learning Aggregate Computing algorithms}
  \begin{cardTiny}
    \begin{itemize}
      \item \highlight{Aggregate Computing Algorithms}: Function from Field to Field (Collective Data Structure)
      \item Building blocks: Set of self-organisation pattern for collective application
      \begin{itemize}
        \item G: \emph{gradient-cast} \faArrowRight \,  information sharing outwards a source
        \item C: \emph{collect} \faArrowRight \, infromation collection inwards a source
        \item S: \emph{sparse choice} \faArrowRight \, distributed leader election
        \item \dots
      \end{itemize}
      \item Each block could have several implementations \emph{reasons} \faArrowRight \, different non-functional
      outcomes:
      \begin{itemize}
        \item time constrainsts
        \item highly dynamic environment
        \item \dots
      \end{itemize}
      \item[\failure{\faThumbsDown}] hand-crafted building block concerns:
      \begin{itemize}
        \item complex parameter tuning
        \item complex definition in unknown environment
        \item hard to use in non-stationary environment (when should i change the block implementations?)
      \end{itemize}
    \end{itemize}
  \end{cardTiny}
  \begin{card}[The gradient algorithm]
    \begin{itemize}
      \item A function mapping a Boolean field of sources to the field of minimum distances from those sources
      \begin{itemize}
        \item \emph{progressive}: they take time  to converge to the ``correct'' value
        \item \emph{self-healing}: hey can adjust their output following changes in
        their inputs and the system topology
      \end{itemize}
      \item \highlight{Non-functionality} concerns:
      \begin{itemize}
        \item convergence time \faArrowRight \, CRF, BIS, SVD
        \item output smothness \faArrowRight \, Flex
      \end{itemize}
    \end{itemize}
  \end{card}
  \begin{card}[Proposed apporach: Program sketching / synthesis]
    \begin{itemize}
      \item Designers continue to used high-level block \& API
      \item Part of programs contains \emph{holes} related to non-functional aspects
      \item A Machine Learning algorithm fill these \emph{holes}
      \begin{itemize}
        \item following a non-functional specification (energy, time, message exchanged, \dots)
        \item using raw experience (i.e., online continual learning) or through simulations \& data \faArrowRight \, adaptivity
      \end{itemize}
    \end{itemize}
  \end{card}
  \framebreak
  \begin{card}[Preliminary work: fill holes through experience with Q-Learning~\cite{aguzzi2022towards}]
    \begin{itemize}
      \item Aggragate program evalaution combined with RL loop
      \item During the evalaution, the missed part if refined with Q-Learning
      \item \highlight{Schema}: Centralised Traning / Decentralised Execution
      \item \highlight{Future works}: policy generalization issues, deals with continous state/action, \dots
    \end{itemize}
  \end{card}
  \centering
  \cardImg{img/aggregate-agent-control-architecture-rl.pdf}{0.4\textwidth}
\end{frame}

\begin{frame}[allowframebreaks]{Learning execution strategies and adaptations}
  \begin{cardTiny}
    \begin{itemize}
    \item AC program \faArrowRight \, possibly multiple \emph{execution strategies} that affect
    \begin{itemize}
      \item scheduling of computations
      \item scheduling of communications
      \item retention of messages from neighbours
    \end{itemize}
    \end{itemize}
  \end{cardTiny}
  \begin{card}[Execution strategy]
    \begin{itemize}
      \item Static
      \begin{itemize}
        \item time-based
        \item reactive \faArrowRight \, depends on environment events (messages, sensors, \dots)
      \end{itemize}
      \item Dynamic \faArrowRight \,  adapt the execution choices at
      runtime depending
      \item \emph{Programmable distributed schedulers} \faArrowRight \, an hand-crafted solution to manage collective program scheduling specification
      \item \textbf{Vision} \faArrowRight \, dynamic scheduling via learning or evolutionary appraoch following \emph{high-level} system goals \faArrowRight towards \emph{green autonomic computing}
    \end{itemize}
  \end{card}
  \begin{card}[Preliminary work: Addressing Collective Computations Efficiency through RL]
    \begin{itemize}
      \item RL agent observe the output of a collective computation \emph{locally}
      \item Reward function: try to maxisime the trend of between \emph{converge-time} and \emph{consumption}
      \item Action: next-wake up time
      \item \highlight{Results}: agents eventually find policies that reduce \emph{the collective} power consumption
      \item \emph{Future works}: more robust evelatuation, online learning, \dots
    \end{itemize}
    \cardImg{img/image-rl-500-plain.pdf}{\textwidth}
  \end{card}
\end{frame}

\begin{frame}[allowframebreaks]{Learning system structures and re-structuring}
  \begin{columns}
    \begin{column}[c]{0.65\textwidth}
      \begin{cardTiny}
      \begin{itemize}
        \item Aggregate systems \faArrowRight \, logical network  of logical devices that perform rounds
        \item Extremely flexible model \faArrowRight \, pulverised architecture 
        \item The same program could be executed in several deployment
        \begin{itemize}
          \item Collective specification does not depends on concrete IT Networks
          \item Enable opportunistic code movement (from edge to cloud and viceversa)
        \end{itemize}
        \item[\failure{\faThumbsDown}] Complex deployment definition for a given goal (simulations)
        \item[\success{\faThumbsUp}] \textbf{Vision}: inject ML to let the system learns the effective deployment policy \faArrowRight \,  improving the efficacy and
        efficiency of aggregate applications.
      \end{itemize}
    \end{cardTiny}
  \end{column}
  \begin{column}[c]{0.3\textwidth}
    \cardImg{img/deployments.jpg}{\textwidth}
  \end{column}
  \end{columns}
\end{frame}


\begin{frame}{Conclusion}
  \begin{card}[Recap]
    \begin{itemize}
      \item Aggregate computing \faArrowRight \, effective approach to engineer Collective Intelligence
      \item \highlight{Vision} \faArrowRight \, improve aggregate application (functional \& non-functioanal aspects) through learning:
      \begin{itemize}
        \item Algorithms
        \item Execution strategies
        \item deployments
        \item[\success{\faThumbsUp}] Preliminary work shows good results
      \end{itemize}
      \item Opportunities:
      \begin{itemize}
        \item Automatic desing of CI
        \item Green autonomic computing
      \end{itemize}
      \item Challenges
      \begin{itemize}
        \item Many-agents settings
        \item Distribution
        \item Partial observability
        \item \dots
      \end{itemize}
    \end{itemize}
    
  \end{card}
\end{frame}
\begin{frame}[allowframebreaks]
  \frametitle{References}
  \printbibliography
\end{frame}
\end{document}
